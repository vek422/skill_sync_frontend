import { useEffect, useRef, useCallback } from 'react';
import { useAppDispatch, useAppSelector } from '../store';
import {
    setConnectionStatus,
    setConnectionEstablished,
    startAssessment,
    setAssessmentStarted,
    setAssessmentRecovered,
    completeAssessment,
    setCurrentQuestion,
    submitAnswer as submitAnswerAction,
    setAnswerFeedback,
    updateProgress,
    setError,
    addErrorLog,
    updateLastMessageTimestamp,
    incrementReconnectAttempts,
    resetReconnectAttempts,
    resetAssessment
} from '../store/slices/assessmentSlice';

interface WebSocketMessage {
    type: string;
    data?: any;
    error?: string;
    timestamp?: string;
}

interface UseAssessmentWebSocketOptions {
    testId: number;
    autoStart?: boolean;
    maxReconnectAttempts?: number;
    reconnectDelay?: number;
    websocketUrl?: string;
}

export const useAssessmentWebSocket = ({
    testId,
    autoStart = true,
    maxReconnectAttempts = 5,
    reconnectDelay = 1000,
    websocketUrl = 'ws://localhost:8000'
}: UseAssessmentWebSocketOptions) => {
    const dispatch = useAppDispatch();
    const { token } = useAppSelector(state => state.auth);
    const assessmentState = useAppSelector(state => state.assessment);

    const websocketRef = useRef<WebSocket | null>(null);
    const reconnectTimeoutRef = useRef<number | null>(null);
    const reconnectDelayRef = useRef(reconnectDelay);
    const isManualDisconnectRef = useRef(false);

    // WebSocket URL construction
    const getWebSocketUrl = useCallback(() => {
        if (!token) {
            throw new Error('No authentication token available');
        }
        return `${websocketUrl}/ws/assessment?test_id=${testId}&token=${encodeURIComponent(token)}`;
    }, [websocketUrl, testId, token]);

    // Message handlers based on WebSocket guide
    const handleMessage = useCallback((message: WebSocketMessage) => {
        dispatch(updateLastMessageTimestamp()); switch (message.type) {
            case 'auth_success':
                dispatch(setConnectionEstablished({
                    connection_id: message.data.connection_id,
                    user_id: message.data.user_id,
                    test_id: testId // Use testId from props since it may not be in response
                }));

                // Auto-start assessment if enabled
                if (autoStart) {
                    dispatch(startAssessment({ test_id: testId }));
                    sendMessage({
                        type: 'start_assessment',
                        data: { test_id: testId }
                    });
                }
                break; case 'assessment_started':
                dispatch(setAssessmentStarted({
                    assessment_id: message.data.assessment_id,
                    thread_id: message.data.thread_id,
                    test_id: message.data.test_id
                }));

                // First question is auto-generated by backend, no need to request
                break;

            case 'assessment_recovered':
                dispatch(setAssessmentRecovered({
                    assessment_id: message.data.assessment_id,
                    thread_id: message.data.thread_id,
                    progress: {
                        answered_questions: message.data.progress.answered_questions,
                        total_questions: message.data.progress.total_questions
                    }
                }));

                // Request current question after recovery
                sendMessage({ type: 'get_question' });
                break;

            case 'question':
                console.log("Setting the current question ")
                const raw_question = message.data.question;
                const options = raw_question?.options?.map((option: any) => ({ "option_id": option[0], "option": option.slice(2) }))
                console.log(options)
                dispatch(setCurrentQuestion({
                    question_id: message.data.question_id,
                    thread_id: message.data.thread_id,
                    question: {
                        text: raw_question.prompt,
                        options: options,
                        difficulty: raw_question.meta.difficulty,
                        skill: raw_question.skill,
                        time_limit: message.data.question.time_limit
                    }
                }));
                // must be removed added for testing
                // setTimeout(() => {
                //     sendMessage({ type: 'get_question' });
                // }, 2000);
                break;

            case 'answer_feedback':
                dispatch(setAnswerFeedback({
                    question_id: message.data.question_id,
                    feedback: {
                        correct: message.data.feedback.correct,
                        selected_option: message.data.feedback.selected_option,
                        correct_answer: message.data.feedback.correct_answer,
                        message: message.data.feedback.message
                    },
                    progress: {
                        answered_questions: message.data.progress.answered,
                        total_questions: message.data.progress.total
                    },
                    thread_id: message.data.thread_id
                }));

                // Auto-request next question if not completed
                if (message.data.progress.answered < message.data.progress.total) {
                    console.log(`ðŸ“ Progress: ${message.data.progress.answered}/${message.data.progress.total} - requesting next question`);
                    // Questions are auto-generated after feedback, no manual request needed
                    setTimeout(() => {
                        sendMessage({ type: 'get_question' });
                    }, 1500);
                } else {
                    console.log(`âœ… All questions answered: ${message.data.progress.answered}/${message.data.progress.total} - waiting for backend completion signal`);
                }
                sendMessage({ type: 'get_question' });
                break;

            case 'progress_update':
                dispatch(updateProgress({
                    answered_questions: message.data.answered_questions,
                    total_questions: message.data.total_questions
                }));
                break;

            case 'assessment_completed':
                console.log('ðŸ Assessment completion received from backend:', message.data);
                dispatch(completeAssessment({
                    final_score: message.data.results?.final_score || 0,
                    correct_answers: message.data.results?.correct_answers || 0,
                    total_questions: message.data.results?.total_questions || 0,
                    assessment_id: message.data.results?.assessment_id || '',
                    thread_id: message.data.results?.thread_id || ''
                }));
                break;

            case 'error':
                const errorData = message.data || {};
                dispatch(setError({
                    message: errorData.error || 'Unknown error occurred',
                    code: errorData.code,
                    details: errorData.details,
                    recoverable: errorData.recoverable
                }));

                // Handle specific error types based on error message content
                const errorMessage = errorData.error || '';

                if (errorMessage.includes('Authentication failed') || errorMessage.includes('Invalid token')) {
                    dispatch(addErrorLog({
                        type: 'auth_error',
                        message: 'Authentication failed - token invalid or expired',
                        recoverable: false
                    }));
                } else if (errorMessage.includes('Access denied')) {
                    dispatch(addErrorLog({
                        type: 'access_error',
                        message: 'Access denied - no permission for this test',
                        recoverable: false
                    }));
                } else if (errorMessage.includes('Test not found')) {
                    dispatch(addErrorLog({
                        type: 'test_error',
                        message: 'Test not found',
                        recoverable: false
                    }));
                } else if (errorMessage.includes('Failed to generate question')) {
                    dispatch(addErrorLog({
                        type: 'question_error',
                        message: 'Question generation failed',
                        recoverable: true
                    }));
                    // Retry question generation after delay
                    setTimeout(() => {
                        sendMessage({ type: 'get_question' });
                    }, 2000);
                }
                break;

            case 'system_message':
                // Handle AI chat responses
                console.log('System message received:', message.data.message);
                dispatch(addErrorLog({
                    type: 'system_message',
                    message: message.data.message,
                    recoverable: true
                }));
                break;

            case 'pong':
                // Handle heartbeat response
                console.log('Heartbeat response received at:', message.data.timestamp);
                dispatch(updateLastMessageTimestamp());
                break;

            case 'test_info':
                // Handle test info response for debugging
                console.log('ðŸ“‹ Test Info Response:', message.data);
                break;

            default:
                console.warn('Unknown message type:', message.type);
                dispatch(addErrorLog({
                    type: 'unknown_message',
                    message: `Received unknown message type: ${message.type}`,
                    recoverable: true
                }));
        }
    }, [dispatch, testId, autoStart]);

    // Send message through WebSocket
    const sendMessage = useCallback((message: any) => {
        if (websocketRef.current?.readyState === WebSocket.OPEN) {
            const messageWithTimestamp = {
                ...message,
                timestamp: new Date().toISOString()
            };

            // Debug logging
            if (import.meta.env.DEV) {
                console.log('ðŸ“¤ Sending:', messageWithTimestamp);
            }

            websocketRef.current.send(JSON.stringify(messageWithTimestamp));
            dispatch(updateLastMessageTimestamp());
        } else {
            dispatch(addErrorLog({
                type: 'send_error',
                message: 'Cannot send message - WebSocket not connected',
                recoverable: true
            }));
        }
    }, [dispatch]);

    // Connect to WebSocket
    const connect = useCallback(() => {
        try {
            dispatch(setConnectionStatus('connecting'));

            const wsUrl = getWebSocketUrl();
            const ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected to assessment');
                websocketRef.current = ws;
                dispatch(resetReconnectAttempts());
                reconnectDelayRef.current = reconnectDelay;
                isManualDisconnectRef.current = false;
            };

            ws.onmessage = (event) => {
                try {
                    const message: WebSocketMessage = JSON.parse(event.data);

                    // Debug logging
                    if (import.meta.env.DEV) {
                        console.log('ðŸ“¨ Received:', message);
                    }

                    handleMessage(message);
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error);
                    dispatch(addErrorLog({
                        type: 'parse_error',
                        message: 'Failed to parse WebSocket message',
                        details: error instanceof Error ? error.message : 'Unknown parse error',
                        recoverable: true
                    }));
                }
            };

            ws.onclose = (event) => {
                console.log('WebSocket disconnected:', event.code, event.reason);
                websocketRef.current = null;
                dispatch(setConnectionStatus('disconnected'));

                // Only attempt reconnection if it wasn't a manual disconnect
                if (!isManualDisconnectRef.current &&
                    !event.wasClean &&
                    assessmentState.reconnect_attempts < maxReconnectAttempts) {
                    scheduleReconnect();
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                dispatch(setError({
                    message: 'WebSocket connection error',
                    recoverable: true
                }));
            };

        } catch (error) {
            dispatch(setError({
                message: error instanceof Error ? error.message : 'Failed to connect to WebSocket',
                recoverable: true
            }));
        }
    }, [dispatch, getWebSocketUrl, handleMessage, assessmentState.reconnect_attempts, maxReconnectAttempts, reconnectDelay]);

    // Schedule reconnection with exponential backoff
    const scheduleReconnect = useCallback(() => {
        dispatch(incrementReconnectAttempts());
        dispatch(setConnectionStatus('reconnecting'));

        console.log(
            `Scheduling reconnect attempt ${assessmentState.reconnect_attempts + 1} in ${reconnectDelayRef.current}ms`
        );

        reconnectTimeoutRef.current = setTimeout(() => {
            connect();
        }, reconnectDelayRef.current) as unknown as number;

        // Exponential backoff with max delay of 30 seconds
        reconnectDelayRef.current = Math.min(reconnectDelayRef.current * 2, 30000);
    }, [dispatch, connect, assessmentState.reconnect_attempts]);

    // Disconnect WebSocket
    const disconnect = useCallback(() => {
        isManualDisconnectRef.current = true;

        if (reconnectTimeoutRef.current) {
            clearTimeout(reconnectTimeoutRef.current);
            reconnectTimeoutRef.current = null;
        }

        if (websocketRef.current) {
            websocketRef.current.close(1000, 'Manual disconnect');
            websocketRef.current = null;
        }

        dispatch(setConnectionStatus('disconnected'));
    }, [dispatch]);

    // Public API methods
    const submitAnswer = useCallback((questionId: string, selectedOption: string) => {
        // Find the option text from current question
        const optionText = assessmentState.current_question?.options.find(
            opt => opt.option_id === selectedOption
        )?.option || selectedOption;

        // Store response in Redux first
        dispatch(submitAnswerAction({
            question_id: questionId,
            selected_option: selectedOption,
            option_text: optionText
        }));

        // Then send to server
        sendMessage({
            type: 'submit_answer',
            data: {
                question_id: questionId,
                selected_option: selectedOption
            }
        });
    }, [sendMessage, dispatch, assessmentState.current_question]);

    const requestQuestion = useCallback(() => {
        sendMessage({ type: 'get_question' });
    }, [sendMessage]);

    const requestProgress = useCallback(() => {
        sendMessage({ type: 'get_progress' });
    }, [sendMessage]);

    const completeAssessmentRequest = useCallback(() => {
        sendMessage({ type: 'complete_assessment' });
    }, [sendMessage]);

    const startAssessmentSession = useCallback(() => {
        dispatch(startAssessment({ test_id: testId }));
        sendMessage({
            type: 'start_assessment',
            data: { test_id: testId }
        });
    }, [dispatch, sendMessage, testId]);

    const resetAssessmentSession = useCallback(() => {
        dispatch(resetAssessment());
        disconnect();
    }, [dispatch, disconnect]);

    // Chat functionality
    const sendChatMessage = useCallback((message: string) => {
        sendMessage({
            type: 'chat_message',
            data: { message }
        });
    }, [sendMessage]);

    // Heartbeat functionality
    const sendHeartbeat = useCallback(() => {
        sendMessage({ type: 'heartbeat' });
    }, [sendMessage]);

    // Auto-heartbeat every 30 seconds when connected
    useEffect(() => {
        let heartbeatInterval: number | null = null;

        if (assessmentState.connection_status === 'connected') {
            heartbeatInterval = setInterval(() => {
                sendHeartbeat();
            }, 30000) as unknown as number; // Send heartbeat every 30 seconds
        }

        return () => {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
            }
        };
    }, [assessmentState.connection_status, sendHeartbeat]);

    // Initialize connection on mount
    useEffect(() => {
        if (token && testId) {
            connect();
        }

        // Cleanup on unmount
        return () => {
            if (reconnectTimeoutRef.current) {
                clearTimeout(reconnectTimeoutRef.current);
            }
            if (websocketRef.current) {
                websocketRef.current.close();
            }
        };
    }, [connect, token, testId]);

    // Return hook interface
    return {
        // State
        connectionStatus: assessmentState.connection_status,
        assessmentStarted: assessmentState.assessment_started,
        assessmentCompleted: assessmentState.assessment_completed,
        currentQuestion: assessmentState.current_question,
        progress: assessmentState.progress,
        currentError: assessmentState.current_error,
        reconnectAttempts: assessmentState.reconnect_attempts,

        // Actions
        connect,
        disconnect,
        submitAnswer,
        requestQuestion,
        requestProgress,
        completeAssessment: completeAssessmentRequest,
        startAssessment: startAssessmentSession,
        resetAssessment: resetAssessmentSession,
        sendChatMessage,
        sendHeartbeat,
        sendMessage, // Add generic sendMessage function

        // Utils
        isConnected: assessmentState.connection_status === 'connected',
        isConnecting: assessmentState.connection_status === 'connecting',
        isReconnecting: assessmentState.connection_status === 'reconnecting',
        hasError: !!assessmentState.current_error
    };
};
